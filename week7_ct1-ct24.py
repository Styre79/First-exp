# 1 Количество различных чисел
# Дан список чисел, который может содержать до 100000 чисел.Определите, сколько в нем встречается различных чисел.
# Вводится список целых чисел. Все числа списка находятся на одной строке.
s = set(map(int, input().split()))
print(len(s))

# 2* Количество совпадающих
# Даны два списка чисел, которые могут содержать до 100000 чисел каждый.
# Посчитайте, сколько чисел содержится одновременно как в первом списке, так и во втором.
# Эту задачу на Питоне можно решить в одну строчку.
# Вводятся два списка чисел. Все числа каждого списка находятся на отдельной строке.
l1 = set(input().split())
l2 = set(input().split())
print(len(l1 & l2))

# 3 Пересечение множеств
# Даны два списка чисел, которые могут содержать до 10000 чисел каждый. Выведите все числа,
# которые входят как в первый, так и во второй список, в порядке возрастания.
s1 = set(map(int, input().split()))
s2 = set(map(int, input().split()))
print(*sorted(s1 & s2))

# 4 Встречалось ли число раньше
# Во входной строке записана последовательность чисел через пробел. Для каждого числа выведите слово YES
# (в отдельной строке), если это число ранее встречалось в последовательности или NO, если не встречалось.
# Вводится список чисел. Все числа списка находятся на одной строке.
l1 = list(map(int, input().split()))
s = set()
for elem in l1:
    if elem in s:
        print('YES')
    else:
        print('NO')
        s.add(elem)

# 5* Кубики
# Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики
# различны по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета
# присутствуют в обоих наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк,
# поэтому вам предлагается помочь им в оставшейся части. Номер любого цвета — это целое число в пределах от 0 до 10⁹.
# В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно.
# В следующих N строках заданы номера цветов кубиков Ани. В последних M строках  номера цветов кубиков Бори.
# Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета
# есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани,
# потом количество и отсортированные по возрастанию номера остальных цветов у Бори.
sa, sb = set(), set()
inf = open('input.txt', 'r', encoding='utf-8')
n, m = map(int, inf.readline().strip().split())
for i in range(n):
    color = int(inf.readline().strip())
    sa.add(color)
for i in range(m):
    color = int(inf.readline().strip())
    sb.add(color)
inf.close()
jointcolors = sa & sb
sa -= jointcolors
sb -= jointcolors
print(len(jointcolors))
print(*sorted(jointcolors))
print(len(sa))
print(*sorted(sa))
print(len(sb))
print(*sorted(sb))

# 6 Количество слов в тексте
# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или
# символами конца строки. Определите, сколько различных слов содержится в этом тексте.
text = set()
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    text |= set(line.strip().split())
inf.close()
print(len(text))

# 7 Угадай число
# Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число,
# для этого она называет некоторые множества натуральных чисел. Август отвечает Беатрисе YES, если среди названных ею
# чисел есть задуманное или NO в противном случае. После нескольких заданных вопросов Беатриса запуталась в том,
# какие вопросы она задавала и какие ответы получила и просит вас помочь ей определить, какие числа мог задумать Август.
# Первая строка входных данных содержит число n — наибольшее число, которое мог загадать Август. Далее идут строки,
# содержащие вопросы Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. После каждой строки
# с вопросом идет ответ Августа: YES или NO.  Наконец, последняя строка входных данных содержит одно слово HELP.
# Вы должны вывести (через пробел, в порядке возрастания) все числа, которые мог задумать Август.
inf = open('input.txt', 'r', encoding='utf-8')
line = int(inf.readline().strip())
s_to_n = {i for i in range(1, line + 1)}
for line in inf:
    line = line.strip().split()
    if line:
        if line == ['YES']:
            s_to_n &= req_num
        elif line == ['NO']:
            s_to_n -= req_num
        elif line != ['HELP']:
            req_num = set(map(int, line))
inf.close()
print(*sorted(s_to_n))

# 8* Угадай число - 2
# Август и Беатриса продолжают играть в игру, но Август начал жульничать. На каждый из вопросов Беатрисы он выбирает
# такой вариант ответа YES или NO, чтобы множество возможных задуманных чисел оставалось как можно больше.
# Например, если Август задумал число от 1 до 5, а Беатриса спросила про числа 1 и 2, то Август ответит NO,
# а если Беатриса спросит про 1, 2, 3, то Август ответит YES. Если же Бетриса в своем вопросе перечисляет ровно
# половину из задуманных чисел, то Август из вредности всегда отвечает NO. Наконец, Август при ответе учитывает все
# предыдущие вопросы Беатрисы и свои ответы на них, то есть множество возможных задуманных чисел уменьшается.
# Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа на них. Первая строка входных данных содержит
# число n — наибольшее число, которое мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы.Каждая строка
# представляет собой набор чисел, разделенных пробелами. Последняя строка входных данных содержит одно слово HELP.
# Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После этого выведите (через пробел, в порядке
# возрастания) все числа, которые мог загадать Август после ответа на всевопросы Беатрисы.
inf = open('input.txt', 'r', encoding='utf-8')
line = int(inf.readline().strip())
s_to_n = {i for i in range(1, line + 1)}
for line in inf:
    line = line.strip().split()
    if line:
        if line != ['HELP']:
            req_num = set(map(int, line))
            if len(req_num & s_to_n) > len(s_to_n) / 2:
                s_to_n &= req_num
                print('YES')
            else:
                s_to_n -= req_num
                print('NO')
inf.close()
print(*sorted(s_to_n))

# 9 Полиглоты
# Каждый из N школьников некоторой школы знает Mᵢ языков. Определите, какие языки знают все школьники и языки, которые
# знает хотя бы один из школьников. Первая строка входных данных содержит количество школьников N.
# Далее идет N чисел Mᵢ, после каждого из чисел идет Mᵢ строк, содержащих названия языков, которые знает i-й школьник.
# Длина названий языков не превышает 1000 символов, количество различных языков не более 1000. 1≤N≤1000, 1≤Mᵢ≤500.
# В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких
# языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков.
all_set, one_set, stud_lang = set(), set(), set()
inf = open('input.txt', 'r', encoding='utf-8')
qty_stud = int(inf.readline().strip())
for i in range(qty_stud):
    qty_lang = int(inf.readline().strip())
    for j in range(qty_lang):
        lang = inf.readline().strip()
        stud_lang.add(lang)
        if i == 0:
            all_set.add(lang)
    one_set |= stud_lang
    all_set &= stud_lang
    stud_lang.clear()
inf.close()
print(len(all_set))
for elem in all_set:
    print(elem)
print(len(one_set))
for elem in one_set:
    print(elem)

# 10* Пересадки
# На Новом проспекте для разгрузки было решено пустить два новых автобусных маршрута на разных участках проспекта.
# Известны конечные остановки каждого из автобусов. Определите количество остановок, на  которых можно пересесть с
# одного автобуса на другой. Вводятся четыре числа, не превосходящие 100, задающие номера конечных остановок.
# Сначала для первого, потом второго автобуса (см. примеры и рисунок).
# Ваша программа должна выводить одно число – искомое количество остановок.
b1st1, b1st2, b2st1, b2st2 = map(int, input().split())
allstb1 = set(range(min(b1st1, b1st2), max(b1st1, b1st2) + 1))
allstb2 = set(range(min(b2st1, b2st2), max(b2st1, b2st2) + 1))
print(len(allstb1 & allstb2))

# 11* Забастовки
# Политическая жизнь одной страны очень оживленная. В стране действует K политических партий, каждая из которых
# регулярно объявляет национальную забастовку. Дни, когда хотя бы одна из партий объявляет забастовку, при условии, что
# это не суббота или воскресенье (когда и так никто не работает), наносят большой ущерб экономике страны.
# i-я партия объявляет забастовки строго каждые bᵢ дней, начиная с дня с номером aᵢ. То есть i-я партия объявляет
# забастовки в дни aᵢ, aᵢ+bᵢ, aᵢ+2bᵢ и т.д. Если в какой-то день несколько партий объявляет забастовку, то это
# считается одной общенациональной забастовкой. В календаре страны N дней, пронумерованных от 1 до N.
# Первый день года является понедельником, шестой и седьмой дни года — выходные, неделя состоит из семи дней.
# Программа получает на вход число дней в году N (1≤N≤10⁶) и число политических партий K (1≤K≤100). Далее идет K строк,
# описывающие графики проведения забастовок.i-я строка содержит числа aᵢ и bᵢ (1≤aᵢ,bᵢ≤N).
# Выведите единственное число: количество забастовок, произошедших в течение года.
# Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия объявляет забастовки в дни 3, 8, 13, 18.
# Третья партия — в дни 9 и 17. Дни номер 6, 7, 13, 14 являются выходными.
# Таким образом, забастовки пройдут в дни 2, 3, 5, 8, 9, 11, 17, 18.
holidays, allpsdays = set(), set()
inf = open('input.txt', 'r', encoding='utf-8')
n, k = map(int, inf.readline().strip().split())
for i in range(6, n + 1, 7):
    holidays.add(i)
    holidays.add(i + 1)
for line in inf:
    psday, period = map(int, line.strip().split())
    psdaysset = set(range(psday, n + 1, period))
    allpsdays |= psdaysset
    # if len(allpsdays) == n - len(holidays): # for acceleration
    #     break
print(len(allpsdays - holidays))

# 12* Телефонные номера
# Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов:
#     +7<код><номер>
#     8<код><номер>
#     <номер>
# где <номер> — это семь цифр, а <код> — это три цифры или три цифры в круглых скобках. Если код не указан,
# то считается, что он равен 495. Кроме того, в записи телефонного номера может стоять знак “-” между любыми
# двумя цифрами (см. пример). На данный момент в адресной книге телефона Васи записано всего три телефонных номера,
# и он хочет записать туда еще один. Но он не может понять, не записан ли уже такой номер в телефонной книге.
# Помогите ему! Два телефонных номера совпадают, если у них равны коды и равны номера. Например,
# +7(916)0123456 и 89160123456 — это один и тот же номер.
# В первой строке входных данных записан номер телефона, который Вася хочет добавить в адресную книгу своего телефона.
# В следующих трех строках записаны три номера телефонов, которые уже находятся в адресной книге телефона Васи.
# Гарантируется, что каждая из записей соответствует одному из трех приведенных в условии форматов.
# Для каждого телефонного номера в адресной книге выведите YES, если он совпадает с тем телефонным номером,
# который Вася хочет добавить в адресную книгу или NO в противном случае.
def standart_num(number):
    code = ['5', '9', '4']
    st_num = []
    for sign in number:
        if sign.isdigit():
            st_num.append(sign)
    st_num.reverse()
    if len(st_num) == 11:
        st_num.pop()
    else:
        st_num.extend(code)
    return st_num


new = input()
st_new = standart_num(new)
for i in range(3):
    old = input()
    st_old = standart_num(old)
    print('YES' if st_old == st_new else 'NO')

# 13* Страны и города
# Дан список стран и городов каждой страны. Затем даны названия городов.
# Для каждого города укажите, в какой стране он находится.
# Программа получает на вход количество стран N. Далее идет N строк, каждая строка начинается с названия страны,
# затем идут названия городов этой страны. Название каждого город состоит из одного слова.
# В следующей строке записано число M, далее идут M запросов — названия каких-то M городов, перечисленных выше.
# Для каждого из запроса выведите название страны, в котором находится данный город.

# вариант с одним словарем страна:города, но с проходом при каждом запросе по всем ключам
countries = {}
inf = open('input.txt', 'r', encoding='utf-8')
n = int(inf.readline().strip())
for i in range(n):
    line = inf.readline().strip().split()
    countries[line.pop(0)] = set(line)
m = int(inf.readline().strip())
for i in range(m):
    city = inf.readline().strip()
    for country in countries:
        if city in countries[country]:
            print(country)
inf.close()
# вариант с кучей словарей город:страна
cities = {}
inf = open('input.txt', 'r', encoding='utf-8')
n = int(inf.readline().strip())
for i in range(n):
    line = inf.readline().strip().split()
    for j in range(1, len(line)):
        cities[line[j]] = line[0]
m = int(inf.readline().strip())
for i in range(m):
    city = inf.readline().strip()
    print(cities[city])
inf.close()

# 14* Номер появления слова
# Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность
# непробельных подряд идущих символов. Слова разделены одним или большим числом пробелов или символами конца строки.
# Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
word_dict = {}
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    line = line.strip().split()
    for word in line:
        if word not in word_dict:
            word_dict[word] = -1
        word_dict[word] += 1
        print(word_dict[word], end=' ')

# 15 Словарь синонимов
# Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит ровно два
# слова-синонима. После этого следует одно слово. Программа должна вывести синоним к данному слову.
syn_dict = {}
inf = open('input.txt', 'r', encoding='utf-8')
n = int(inf.readline().strip())
for i in range(n):
    synonyms = inf.readline().strip().split()
    syn_dict[synonyms[0]] = synonyms[1]
    syn_dict[synonyms[1]] = synonyms[0]
word = inf.readline().strip()
inf.close()
print(syn_dict[word])

# 16* Выборы в США
# Как известно, в США президент выбирается не прямым голосованием, а путем двухуровневого голосования. Сначала
# проводятся выборы в каждом штате и определяется победитель выборов в данном штате. Затем проводятся государственные
# выборы: на этих выборах каждый штат имеет определенное число голосов — число выборщиков от этого штата. На практике,
# все выборщики от штата голосуют в соответствии с результатами голосования внутри штата, то есть на заключительной
# стадии выборов в голосовании участвуют штаты, имеющие различное число голосов. Вам известно за кого проголосовал
# каждый штат и сколько голосов было отдано данным штатом. Подведите итоги выборов: для каждого из участника
# голосования определите число отданных за него голосов.
# Каждая строка входного файла содержит фамилию кандидата, за которого отдают голоса выборщики этого штата,
# затем через пробел идет количество выборщиков,отдавших голоса за этого кандидата.
# Выведите фамилии всех кандидатов в лексикографическом порядке,затем, через пробел, количество отданных за них голосов.
candidates = {}
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    line = line.strip().split()
    candidates[line[0]] = candidates.get(line[0], 0) + int(line[1])
inf.close()
for key in sorted(candidates):
    print(key, candidates[key])

# 17 Самое частое слово
# Дан текст. Выведите слово, которое в этом тексте встречается чаще всего. Если таких слов несколько, выведите то,
# которое меньше в лексикографическом порядке.
words_dict = {}
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    words = line.strip().split()
    for word in words:
        words_dict[word] = words_dict.get(word, 0) + 1
inf.close()
srl = sorted(words_dict.items(), key=lambda x: (int(-x[1]), x[0]))
print(srl[0][0])

# 18 Частотный анализ
# Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по
# убыванию их количества появления в тексте, а при одинаковой частоте появления — в лексикографическом порядке.
# После того, как вы создадите словарь всех слов, вам захочется отсортировать его по частоте встречаемости слова.
# Желаемого можно добиться, если создать список, элементами которого будут кортежи из двух элементов:
# частота встречаемости слова и само слово. Например, [(2, 'hi'), (1, 'what'), (3, 'is')]. Тогда стандартная сортировка
# будет сортировать список кортежей, при этом кортежи сравниваются по первому элементу, а если они равны —то по второму.
# Это почти то, что требуется в задаче.
words_dict = {}
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    line = line.strip().split()
    for word in line:
        words_dict[word] = words_dict.get(word, 0) + 1
inf.close()
sort_words = sorted(words_dict.items(), key=lambda x: (int(-x[1]), x[0]))
for word in sort_words:
    print(word[0])

# 19 Выборы Президента
# В выборах Президента Российской Федерации побеждает кандидат, набравший свыше половины числа голосов избирателей.
# Если такого кандидата нет, то во второй тур выборов выходят два кандидата, набравших наибольшее число голосов.
# Каждая строка входного файла содержит имя кандидата, за которого отдал голос один избиратель. Известно, что общее
# число кандидатов не превосходит 20, но в отличии от предыдущих задач список кандидатов явно не задан.
# Читайте данные из файла input.txt с указанием кодировки utf8.
# Если есть кандидат, набравший более 50% голосов, программа должна вывести его имя. Если такого кандидата нет,
# программа должна вывести имя кандидата, занявшего первое место, затем имя кандидата, занявшего второе место.
# Выводите данные в файл output.txt с указанием кодировки utf8.
inf = open('input.txt', 'r', encoding='utf-8')
votes = {}
for candidates in inf:
    candidates = candidates.strip()
    votes[candidates] = votes.get(candidates, 0) + 1
inf.close()
barrier = sum(votes.values()) / 2
res_list = sorted(votes, key=votes.get, reverse=True)
ouf = open('output.txt', 'w', encoding='utf-8')
ouf.write(str(res_list[0])+'\n')
if votes[res_list[0]] <= barrier:
    ouf.write(str(res_list[1])+'\n')
ouf.close()

# 20* Выборы депутатов Государственной Думы
# Статья 83 закона “О выборах депутатов Государственной Думы Федерального Собрания Российской Федерации” определяет
# следующий алгоритм пропорционального распределения мест в парламенте. Необходимо распределить 450 мест между партиями,
# участвовавших в выборах. Сначала подсчитывается сумма голосов избирателей, поданных за каждую партию и подсчитывается
# сумма голосов, поданных за все партии. Эта сумма делится на 450, получается величина, называемая “первое избирательное
# частное” (смысл первого избирательного частного - это количество голосов избирателей, которое необходимо набрать для
# получения одного места в парламенте). Далее каждая партия получает столько мест в парламенте, чему равна целая часть
# от деления числа голосов за данную партию на первое избирательное частное.Если после первого раунда распределения
# мест сумма количества мест, отданных партиям, меньше 450, то оставшиеся места передаются по одному партиям, в порядке
# убывания дробной части частного от деления числа голосов за данную партию на первое избирательное частное. Если же
# для двух партий эти дробные части равны, то преимущество отдается той партии, которая получила большее число голосов.
# На вход программе подается список партий, участвовавших в выборах. Каждая строка входного файла содержит название
# партии (строка, возможно, содержащая пробелы), затем, через пробел, количество голосов, полученных данной
# партией – число, не превосходящее 10⁸.
# Программа должна вывести названия всех партий и количество голосов в парламенте, полученных данной партией.
# Названия необходимо выводить в том же порядке, в котором они шли во входных данных.
inf = open('input.txt', 'r', encoding='utf-8')
parties_dict = {}
num, votes_sum = 0, 0
for line in inf:
    line = line.strip().rsplit(maxsplit=1)
    parties_dict[line[0]] = [num, (int(line[1]))]
    votes_sum += int(line[1])
    num += 1
inf.close()
fvq = votes_sum / 450
for party in parties_dict:
    parties_dict[party].append(parties_dict[party][1] // fvq)
    parties_dict[party].append(parties_dict[party][1] % fvq)
sfrem = sorted(parties_dict.items(), key=lambda x: (x[1][3], x[1][1]))
while sum(map(lambda x: x[2], parties_dict.values())) < 450:
    parties_dict[sfrem.pop()[0]][2] += 1
for key in sorted(parties_dict, key=lambda x: x[0]):
    print(key, int(parties_dict[key][2]))

# 21* Продажи
# Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида:
# Покупатель товар количество, где: Покупатель — имя покупателя (строка без пробелов),
# товар — название товара (строка без пробелов), количество — количество приобретенных единиц товара.
# Создайте список всех покупателей, а для каждого покупателя подсчитайте количество приобретенных им единиц
# каждого вида товаров.
# Выведите список всех покупателей в лексикографическом порядке,после имени каждого покупателя выведите двоеточие,
# затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке,
# после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем.
# Информация о каждом товаре выводится в отдельной строке.
inf = open('input.txt', 'r', encoding='utf-8')
customers = {}
for line in inf:
    line = line.strip().split()
    nickname, product, qty = line[0], line[1], int(line[2])
    customers[nickname] = customers.get(nickname, {})
    customers[nickname][product] = customers[nickname].get(product, 0) + qty
inf.close()
for nickname in sorted(customers):
    print(nickname + ':')
    for product in sorted(customers[nickname]):
        print(product, customers[nickname][product])

# 22*  Банковские счета
# Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:
# Пополнение счета клиента.
# Снятие денег со счета.
# Запрос остатка средств на счете.
# Перевод денег между счетами клиентов.
# Начисление процентов всем клиентам.
# Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами (уникальная строка, не содержащая
# пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пополнения,
# снятия или перевода денег, ему заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим
# счетом. Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.
# Входной файл содержит последовательность операций. Возможны следующие операции:
# DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет счета, то счет создается.
# WITHDRAW name sum - снять сумму sum со счета клиента name. Если у клиента нет счета, то счет создается.
# BALANCE name - узнать остаток средств на счету клиента name.
# TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на счет клиента name2.
# Если у какого-либо клиента нет счета, то ему создается счет.
# INCOME p - начислить всем клиентам, у которых открыты счета, p% от суммы счета.
# Проценты начисляются только клиентам с положительным остатком на счету, если у клиента остаток отрицательный,
# то его счет не меняется. После начисления процентов сумма на счету остается целой, то есть начисляется только
# целое число денежных единиц. Дробная часть начисленных процентов отбрасывается.
# Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. Если же у клиента
# с запрашиваемым именем не открыт счет в банке, выведитеERROR.
def deposit(name, amount):
    clients[name] = clients.get(name, 0) + amount


def withdraw(name, amount):
    clients[name] = clients.get(name, 0) - amount


def balance(name):
    if name in clients:
        return clients[name]
    return 'ERROR'


def transfer(name1, name2, amount):
    withdraw(name1, amount)
    deposit(name2, amount)


def income(percent):
    for name in clients:
        if clients[name] > 0:
            clients[name] += int(clients[name] * (percent / 100))


def data_read(line):
    if line[0] == 'DEPOSIT':
        deposit(line[1], int(line[2]))
    if line[0] == 'WITHDRAW':
        withdraw(line[1], int(line[2]))
    if line[0] == 'BALANCE':
        print(balance(line[1]))
    if line[0] == 'TRANSFER':
        transfer(line[1], line[2], int(line[3]))
    if line[0] == 'INCOME':
        income(int(line[1]))


clients = {}
inf = open('input.txt', 'r', encoding='utf-8')
for line in inf:
    line = line.strip().split()
    data_read(line)
inf.close()

# 23* Контрольная по ударениям
# Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе
# проверить это домашнее задание. Вася очень плохо знаком с данной темой,поэтому он нашел словарь, в котором указано,
# как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах,
# которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено
# ровно одно ударение. Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом.
# Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре
# вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку.
# Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество
# ошибок,которое в этом задании насчитает Вася.
# Вводится сначала число N — количество слов в словаре (0≤N≤20000). Далее идет N строк со словами из словаря. Каждое
# слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв. В каждом слове
# заглавная ровно одна буква — та, на которую попадает ударение. Слова в словаре расположены в алфавитном порядке.
# Если есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут в
# произвольном порядке. Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста,
# суммарным объемом не более 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним
# пробелом. Длина каждого слова не превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв
# (заглавными обозначены те буквы, над которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить
# более одного ударения или не поставить ударения вовсе.
# Выведите количество ошибок в Петином тексте, которые найдет Вася.
vocabulary, voclower = set(), set()
mistakes = 0
inf = open('input.txt', 'r', encoding='utf-8')
n = int(inf.readline().strip())
for i in range(n):
    word = inf.readline().strip()
    vocabulary.add(word)
    voclower.add(word.lower())
text = tuple(inf.readline().strip().split())
for word in text:
    upper_count = 0
    for letter in word:
        upper_count += letter.isupper()
        if upper_count == 2:
            break
    if upper_count == 1 and word.lower() not in voclower:
        vocabulary.add(word)
inf.close()
for word in text:
    if word not in vocabulary:
        mistakes += 1
print(mistakes)

# 24* Родословная: подсчет уровней
# В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель. Каждом элементу дерева
# сопоставляется целое неотрицательное число, называемое высотой. У родоначальника высота равна 0, у любого другого
# элемента высота на 1 больше, чем у его родителя.Вам дано генеалогическое древо, определите высоту всех его элементов.
# Программа получает на вход число элементов в генеалогическом древе N. Далее следует N-1 строка, задающие родителя
# для каждого элемента древа, кроме родоначальника.Каждая строка имеет вид имя_потомка имя_родителя.
# Программа должна вывести список всех элементов древа в лексикографическом порядке.После вывода имени каждого
# элемента необходимо вывести его высоту.
tree = {}
inf = open('input.txt', 'r', encoding='utf-8')
n = int(inf.readline().strip())
for i in range(n - 1):
    line = inf.readline().strip().split()
    tree[line[0]] = line[1]
inf.close()
for person in tree.values():
    if person not in tree:
        tree[person] = None
        break
for person in sorted(tree):
    level = 0
    child = person
    while tree[child] in tree:
        level += 1
        child = tree[child]
    print(person, level)
