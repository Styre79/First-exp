# 1
# Напишите программу, которая считывает два целых числа A и B и выводит наибольшее значение из них.
# Числа — целые от 1 до 1000.
a = int(input())
b = int(input())
if a >= b:
    print(a)
else:
    print(b)

# 2
# Даны два целых числа. Программа должна вывести число "1", если первое число больше второго,
# число "2", если второе больше первого или число "0", если они равны.
a = int(input())
b = int(input())
if a > b:
    print(1)
elif a < b:
    print(2)
else:
    print(0)

# 3
# Даны три целых числа. Найдите наибольшее из них (программа должна вывести ровно одно целое число).
a = int(input())
b = int(input())
c = int(input())
if a >= b and a >= c:
    print(a)
elif b >= c:
    print(b)
else:
    print(c)

# 4
# Дано натуральное число. Требуется определить, является ли год с данным номером високосным.
# Если год является високосным, то выведите YES, иначе выведите NO. Напомним, что в соответствии с григорианским
# календарем, год является високосным, если его номер кратен 4, но не кратен 100, или же если он кратен 400.
num = int(input())
if not num % 400 or (not num % 4 and num % 100):
    print('YES')
else:
    print('NO')

# 5
# Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку.
# Даны две различные клетки шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом.
# Программа получает на вход четыре числа от 1 до 8 каждое,
# задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки.
x_start, y_start = int(input()), int(input())
x_finish, y_finish = int(input()), int(input())
if (x_start == x_finish and y_start == y_finish) or \
        not (x_start - 1 <= x_finish <= x_start + 1 and
             y_start - 1 <= y_finish <= y_start + 1):
    print('NO')
else:
    print('YES')

# 6
# В доме несколько подъездов. В каждом подъезде одинаковое количество квартир.
# Квартиры нумеруются подряд, начиная с единицы.
# Может ли в некотором подъезде первая квартира иметь номер x, а последняя – номер y?
x, y = int(input()), int(input())
if not (x - 1) % (y - x + 1):
    print('YES')
else:
    print('NO')

# 7
# Заданы две клетки шахматной доски. Если они покрашены в один цвет, то выведите слово YES,
# а если в разные цвета – то NO.
# Вводятся 4 числа - координаты клеток.
x1, y1 = int(input()), int(input())
x2, y2 = int(input()), int(input())
if (x1 + y1) % 2 == (x2 + y2) % 2:
    print('YES')
else:
    print('NO')

# 8
# Шоколадка имеет вид прямоугольника, разделенного на n×m долек.
# Шоколадку можно один раз разломить по прямой на две части.
# Определите, можно ли таким образом отломить от шоколадки часть, состоящую ровно из k долек.
n, m, k = int(input()), int(input()), int(input())
if (k % n == 0 or k % m == 0) and (k < m * n):
    print('YES')
else:
    print('NO')

# 9
# Для данного числа n<100 закончите фразу “На лугу пасется...” одним из возможных продолжений:
# “n коров”, “n корова”, “n коровы”, правильно склоняя слово “корова”.
#     "n коров", если 10 < n < 20 или последняя цифра n - одна из 0, 5, 6, 7, 8, 9.
#     "n корова", если последняя цифра n == 1.
#     "n коровы" во всех остальных случаях.
# Программа должна вывести введенное число n и одно из слов:
# korov, korova или korovy. Между числом и словом должен стоять ровно один пробел.
n = int(input())
if 10 < n < 20 or n % 10 == 0 or 5 <= n % 10 <= 9:
    print(n, 'korov')
elif n % 10 == 1:
    print(n, 'korova')
else:
    print(n, 'korovy')

# 10
# В математике функция sign(x) (знак числа) определена так:
# sign(x)=1, если x>0,
# sign(x)=-1, если x<0,
# sign(x)=0, если x=0.
# Для данного числа x выведите значение sign(x).
x = int(input())
if x > 0:
    print(1)
elif x < 0:
    print(-1)
else:
    print(0)

# 11
# Даны координаты двух точек на плоскости, требуется определить,
# лежат ли они в одной координатной четверти или нет (все координаты отличны от нуля).
x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
if (x1 * x2 > 0 and y1 * y2 > 0):
    print('YES')
else:
    print('NO')

# 12
# На доске стоит белая шашка. Требуется определить, может ли она попасть в заданную клетку, делая ходы по правилам
# и не пользуясь ходами дамки (т. е. не используя возможность перемещаться назад после превращения в дамку).
# Белые шашки могут ходить по клеткам одного цвета по диагонали вверх-влево или вверх-вправо.
# Ходов может быть несколько!
# Доска имеет размер 8x8, вертикали и горизонтали нумеруются числами от 1 до 8 начиная с левого нижнего угла.
# Исходная и конечная клетки не совпадают.
x1, y1, x2, y2 = int(input()), int(input()), int(input()), int(input())
if ((x1 + y1) % 2 == (x2 + y2) % 2) and \
        (abs(x1 - x2) <= y2 - y1):
    print('YES')
else:
    print('NO')

# 13
# Даны три стороны треугольника a,b,c. Определите тип треугольника с заданными сторонами.
# Выведите одно из четырех слов: rectangular для прямоугольного треугольника, acute для остроугольного треугольника,
# obtuse для тупоугольного треугольника или impossible,
# если треугольника с такими сторонами не существует (считаем, что вырожденный треугольник тоже невозможен).
a, b, c = int(input()), int(input()), int(input())
if a >= b and a >= c:
    m, s1, s2 = a, b, c
elif b >= c:
    m, s1, s2 = b, a, c
else:
    m, s1, s2 = c, a, b
if (m ** 2 == s1 ** 2 + s2 ** 2) and s1 + s2 > m:
    print('rectangular')
elif (m ** 2 < s1 ** 2 + s2 ** 2) and s1 + s2 > m:
    print('acute')
elif (m ** 2 > s1 ** 2 + s2 ** 2) and s1 + s2 > m:
    print('obtuse')
else:
    print('impossible')

# 14
# Даны три целых числа A, B, C. Определить, есть ли среди них хотя бы одно четное и хотя бы одно нечетное.
a, b, c = int(input()), int(input()), int(input())
if (a % 2 != b % 2) or (a % 2 != c % 2):
    print('YES')
else:
    print('NO')

# 15
# Дано три числа. Упорядочите их в порядке неубывания.
# Программа должна считывать три числа a,b,c, затем программа должна менять их значения так,
# чтобы стали выполнены условия a≤b≤c, затем программа выводит тройку a,b,c.
a, b, c = int(input()), int(input()), int(input())
if a <= c <= b:
    b, c = c, b
elif b <= a <= c:
    a, b = b, a
elif b <= c <= a:
    a, b, c = b, c, a
elif c <= a <= b:
    a, b, c = c, a, b
elif c <= b <= a:
    a, c = c, a
print(a, b, c)

# 16
# Даны три целых числа. Определите, сколько среди них совпадающих.
# Программа должна вывести одно из чисел: 3 (если все совпадают),2 (если два совпадает) или 0 (если все числа различны).
a, b, c = int(input()), int(input()), int(input())
if a == b == c:
    print(3)
elif a == b or a == c or b == c:
    print(2)
else:
    print(0)

# 17
# За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером D×E.
# Замок Иф сложен из кирпичей, размером A×B×C. Определите, сможет ли узник выбрасывать кирпичи в море
# через это отверстие (очевидно, стороны кирпича должны быть параллельны сторонам отверстия).
a, b, c = int(input()), int(input()), int(input())
d, e = int(input()), int(input())
if ((a <= d and b <= e) or (a <= e and b <= d)) \
        or ((a <= d and c <= e) or (a <= e and c <= d)) \
        or ((b <= d and c <= e) or (b <= e and c <= d)):
    print('YES')
else:
    print('NO')

# 18
# Есть две коробки, первая размером A₁×B₁×C₁, вторая размером A₂×B₂×C₂.
# Определите, можно ли разместить одну из этих коробок внутри другой, при условии,
# что поворачивать коробки можно только на 90 градусов вокруг ребер.
# Программа получает на вход числа A₁,B₁,C₁,A₂,B₂,C₂.
# Boxes are equal, если коробки одинаковые,
# The first box is smaller than the second one, если первая коробка может быть положена во вторую,
# The first box is larger than the second one, если вторая коробка может быть положена в первую,
# Boxes are incomparable, во всех остальных случаях.
a1, b1, c1 = int(input()), int(input()), int(input())
a2, b2, c2 = int(input()), int(input()), int(input())
if a1 < b1:
    a1, b1 = b1, a1
if b1 < c1:
    b1, c1 = c1, b1  # sort max to min sides of box1
if a1 < b1:
    a1, b1 = b1, a1

if a2 < b2:
    a2, b2 = b2, a2
if b2 < c2:
    b2, c2 = c2, b2  # sort max to min sides of box2
if a2 < b2:
    a2, b2 = b2, a2

if a1 == a2 and b1 == b2 and c1 == c2:
    print('Boxes are equal')
elif a1 <= a2 and b1 <= b2 and c1 <= c2:
    print('The first box is smaller than the second one')  # comparasion box1 vs box2
elif a1 >= a2 and b1 >= b2 and c1 >= c2:
    print('The first box is larger than the second one')
else:
    print('Boxes are incomparable')

# 19
# На склад, который имеет форму прямоугольного параллелепипеда, привезли ноутбуки, упакованные в коробки.
# Каждая коробка также имеет форму прямоугольного параллелепипеда.
# По правилам хранения коробки с ноутбуками должны быть размещены на складе с выполнением следующих двух условий:
# - Стороны коробок должны быть параллельны сторонам склада.
# - Коробку при помещении на склад разрешается расположить где угодно (с выполнением предыдущего условия),
# в том числе на другой коробке, но все коробки должны быть ориентированы одинаково
# (т.е. нельзя одну коробку расположить “стоя”, а другую —“лежа”)
# Напишите программу, которая по размерам склада и размерам коробки с ноутбуком определит
# максимальное количество ноутбуков, которое может быть размещено на складе.
l, w, h = int(input()), int(input()), int(input())
a, b, c = int(input()), int(input()), int(input())
if l < w:
    l, w = w, l
if w < h:
    w, h = h, w  # sort max to min sides of warehouse
if l < w:
    l, w = w, l

if a < b:
    a, b = b, a
if b < c:
    b, c = c, b  # sort max to min sides of notebook boxes
if a < b:
    a, b = b, a

if a > l or b > w or c > h:
    print(0)
else:
    print(max((l // a) * (w // b) * (h // c), (l // a) * (w // c) * (h // b),
              (l // b) * (w // a) * (h // c), (l // b) * (w // c) * (h // a),
              (l // c) * (w // a) * (h // b), (l // c) * (w // b) * (h // a)))

# 20
# В кафе мороженое продают по три шарика и по пять шариков. Можно ли купить ровно k шариков мороженого?
k = int(input())
if k % 3 % 5 == 0 or k % 5 % 3 == 0 or \
        (k > 5 and k % 5 == 1) or (k > 5 and k % 5 == 4) \
        or (k > 3 and k % 3 == 2):
    print('YES')
else:
    print('NO')

# 21
# Решить в целых числах уравнение: (ax+b) / (cx+d) =0. c и d не равны нулю одновременно.
# Необходимо вывести все решения, если их число конечно, “NO” (без кавычек), если решений нет,
# и “INF” (без кавычек), если решений бесконечно много.
a, b, c, d = int(input()), int(input()), int(input()), int(input())
if a == 0 and b == 0:
    print('INF')
elif c == 0 or d == 0 or (a == 0 and b != 0) or \
        (a != 0 and b == 0 and d == 0) or (c * (-b / a) + d == 0) \
        or -b % a != 0:
    print('NO')
else:
    print(int(-b / a))  # NO WORK 50/100
# списано с форума !!! - работает
a, b, c, d = int(input()), int(input()), int(input()), int(input())
if a == 0:
    print('INF')
elif (-b % a) != 0 or (c * int(-b / a) + d == 0):
    print('NO')
else:
    print(int(-b / a))

# 22
# На сковородку одновременно можно положить k котлет.
# Каждую котлету нужно с каждой стороны обжаривать m минут непрерывно.
# За какое наименьшее время удастся поджарить с обеих сторон n котлет?
k, m, n = int(input()), int(input()), int(input())
if n < k:
    print(m * 2)
elif n * 2 % k == 0:
    print(n * 2 // k * m)
else:
    print(n * 2 // k * m + m)

# 23
# Вдоль прямой выложены три спички. Необходимо переложить одну из них так,
# чтобы при поджигании любой спички сгорали все три. Для того чтобы огонь переходил с одной спички на другую,
# необходимо чтобы эти спички соприкасались (хотя бы концами).
# l₁, r₁, l₂, r₂, l₃, r₃ – координаты первой, второй и третьей спичек соответственно
# (0≤lᵢ<rᵢ≤100). Каждая спичка описывается координатами левого и правого концов по горизонтальной оси OX
# Выведите номер искомой спички. Если возможных ответов несколько, то выведите наименьший из них
# (наименьший по номеру спички). В случае, когда нет необходимости перемещать какую-либо спичку, выведите 0.
# Если же требуемого результата достигнуть невозможно, то выведите -1.
l1, r1, l2, r2 = int(input()), int(input()), int(input()), int(input())
l3, r3 = int(input()), int(input())
if ((l1 <= r2 and l2 <= r1) and
    ((l1 <= r3 and l3 <= r1) or (l2 <= r3 and l3 <= r2))) \
        or ((l2 <= r3 and l3 <= r2) and
            ((l1 <= r2 and l2 <= r1) or (l1 <= r3 and l3 <= r1))) \
        or ((l1 <= r3 and l3 <= r1) and
            ((l1 <= r2 and l2 <= r1) or (l2 <= r3 and l3 <= r2))):
    print(0)
elif (l2 <= r3 and l3 <= r2) or \
        (0 <= l3 - r2 <= r1 - l1) or (0 <= l2 - r3 <= r1 - l1):
    print(1)
elif (l1 <= r3 and l3 <= r1) or \
        (0 <= l3 - r1 <= r2 - l2) or (0 <= l1 - r3 <= r2 - l2):
    print(2)
elif (l1 <= r2 and l2 <= r1) or \
        (0 <= l2 - r1 <= r3 - l3) or (0 <= l1 - r2 <= r3 - l3):
    print(3)
else:
    print(-1)

# 24 Упаковка*
# В одну транспортную компанию поступил заказ на перевозку двух ящиков из одного города в другой.
# Для перевозки ящики решено было упаковать в специальный контейнер.
# Ящики и контейнер имеют вид прямоугольных параллелепипедов.
# Длина, ширина и высота первого ящика  —  l₁,w₁ и h₁, соответствующие размеры второго ящика – l₂,w₂ и h₂.
# Контейнер имеет длину, ширину и высоту lc,wc и hc.
# Поскольку ящики содержат хрупкое оборудование,
# после упаковки в контейнер каждый из них должен остаться в строго вертикальном положении.
# Таким образом, ящики можно разместить рядом или один на другом.
# Для надежного закрепления в контейнере стороны ящиков должны быть параллельны его сторонам.
# Иначе говоря, если исходно ящики были расположены так,
# что все их стороны параллельны соответствующим сторонам контейнера,
# то каждый из них разрешается перемещать и поворачивать относительно вертикальной оси на угол,
# кратный 90 градусам (относительно горизонтальной оси ни контейнер, ни ящики поворачивать нельзя).
# Разумеется, после упаковки оба ящика должны полностью находиться внутри контейнера и не должны пересекаться.
# Выясните, можно ли поместить ящики в контейнер с соблюдением указанных условий.
l1, w1, h1 = int(input()), int(input()), int(input())
l2, w2, h2 = int(input()), int(input()), int(input())
lc, wc, hc = int(input()), int(input()), int(input())
if hc >= (h1 + h2) and \
        (l1 <= lc and w1 <= wc or l1 <= wc and w1 <= lc) and \
        (l2 <= lc and w2 <= wc or l2 <= wc and w2 <= lc):
    print('YES')
elif (hc >= h1 and hc >= h2) and \
        (((l1 + l2 <= lc and w1 <= wc and w2 <= wc) or
          (l1 + l2 <= wc and w1 <= lc and w2 <= lc)) or
         ((l1 + w2 <= lc and l2 <= wc and w1 <= wc) or
          (l1 + w2 <= wc and l2 <= lc and w1 <= lc)) or
         (l2 + w1 <= lc and l1 <= wc and w2 <= wc) or
         (l2 + w1 <= wc and l1 <= lc and w2 <= lc) or
         (w1 + w2 <= lc and l1 <= wc and l2 <= wc) or
         (w1 + w2 <= wc and l1 <= lc and l2 <= lc)):
    print('YES')
else:
    print('NO')

# 25 Список квадратов
# По данному целому числу N распечатайте все квадраты натуральных чисел,не превосходящие N, в порядке возрастания.
n = int(input())
i = 1
while i ** 2 <= n:
    print(i ** 2, end=' ')
    i += 1

# 26 Минимальный делитель
# Дано целое число, не меньшее 2. Выведите его наименьший натуральный делитель, отличный от 1.
n = int(input())
i = 2
while n % i != 0:
    i += 1
print(i - 1)

# 27 Список степеней двойки
# По данному числу N распечатайте все целые степени двойки, не превосходящие N, в порядке возрастания.
# Операцией возведения в степень пользоваться нельзя!
n = int(input())
i = 1
while i <= n:
    print(i, end=' ')
    i = i * 2

# 28 Точная степень двойки
# Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки,
# или слово NO в противном случае. Операцией возведения в степень пользоваться нельзя!
n = int(input())
i = 1
while i <= n:
    i = i * 2
if i // 2 == n:
    print('YES')
else:
    print('NO')

# 29 Двоичный логарифм
# По данному натуральному числу N выведите такое наименьшее целое число k, что 2ᵏ≥N.
# Операцией возведения в степень пользоваться нельзя!
n = int(input())
k = 0
degreeTwo = 1
while degreeTwo < n:
    degreeTwo *= 2
    k += 1
print(k)

# 30 Утренняя пробежка
# В первый день спортсмен пробежал X километров,
# а затем он каждый день увеличивал пробег на 10% от предыдущего значения
# (для решения задачи разрешается использовать числа с запятой, которые в Питоне пишутся через точку).
# По данному числу X определите номер дня, на который пробег спортсмена составит не менее Y километров.
x, y = int(input()), int(input())
days = 1
while x < y:
    days += 1
    x += 0.1 * x
print(days)

# 31 Максимум последовательности
# Последовательность состоит из целых чисел и завершается числом 0.
# Определите значение наибольшего элемента последовательности.
nMax = 0
n = int(input())
while n != 0:
    if n > nMax:
        nMax = n
    n = int(input())
print(nMax)

# 32 Сумма квадратов
# По данному натуральному n вычислите сумму 1²+2²+3²+...+n².
n = int(input())
total = 0
while n >= 1:
    total += n ** 2
    n -= 1
print(total)

# 33 Длина последовательности
# Программа получает на вход последовательность целых неотрицательных чисел, каждое число записано в отдельной строке.
# Последовательность завершается числом 0, при считывании которого программа должна закончить свою работу и
# вывести количество членов последовательности (не считая завершающего числа 0).
# Числа, следующие за числом 0, считывать не нужно.
num = int(input())
count = 0
while num != 0:
    count += 1
    num = int(input())
print(count)

# 34 Сумма последовательности
# Определите сумму всех элементов последовательности, завершающейся числом 0.
num = int(input())
total = num
while num != 0:
    num = int(input())
    total += num
print(total)

# 35 Среднее значение последовательности
# Определите среднее значение всех элементов последовательности, завершающейся числом 0.
# Использовать массивы в данной задаче нельзя.
num = int(input())
total = num
count = 1
while num != 0:
    count += 1
    num = int(input())
    total += num
print(total / (count - 1))

# 36 Количество четных элементов последовательности
# Определите количество четных элементов в последовательности, завершающейся числом 0.
num = int(input())
total_even = 0
while num != 0:
    if num % 2 == 0:
        total_even += 1
    num = int(input())
print(total_even)

# 37 Количество элементов, больше предыдущего
# Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите, сколько элементов этой последовательности больше предыдущего элемента.
num = int(input())
total_more = 0
prev_num = num
while num != 0:
    num = int(input())
    if num > prev_num:
        total_more += 1
    prev_num = num
print(total_more)

# 38 Второй максимум
# Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите значение второго по величине элемента в этой последовательности, то есть элемента,
# который будет наибольшим, если из последовательности удалить одно вхождение наибольшего элемента.
num = int(input())
max_prev = num
max_num = int(input())
if max_num < max_prev:
    num = max_num
    max_prev, max_num = max_num, max_prev
while num != 0:
    if num >= max_num:
        max_prev = max_num
        max_num = num
    elif max_prev < num < max_num:
        max_prev = num
    num = int(input())
print(max_prev)

# 39 Количество элементов, равных максимуму
# Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите количество элементов этой последовательности, которые равны ее наибольшему элементу.
num = int(input())
count = 0
max_num = num
while num != 0:
    if num == max_num:
        count += 1
    elif num > max_num:
        max_num = num
        count = 1
    num = int(input())
print(count)

# 40 Числа Фибоначчи
# Последовательность Фибоначчи определяется так:
# F[0] = 0, F[1] = 1, ..., F[n] = F[n-1] + F[n-2].
# По данному числу n определите n-е число Фибоначчи F[n].
num = int(input())
count = 1
f1, f2 = 0, 1
f_num = 0
while count <= num:
    f_num = f1 + f2
    f1, f2 = f_num, f1
    count += 1
print(f_num)

# 41  Номер числа Фибоначчи
# Последовательность Фибоначчи определяется так:
# F[0]=0, F[1]=1, ..., F[n]=F[n-1]+F[n-2].
# Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является,
# то есть выведите такое число n, что F[n]=A.
# Если А не является числом Фибоначчи, выведите число -1.
a = int(input())
count = 1
f1, f2 = 0, 1
f_num = 0
while f_num < a:
    f_num = f1 + f2
    f1, f2 = f_num, f1
    count += 1
if a == f_num:
    print(count)
else:
    print(-1)

# 42 Исполнитель раздвоитель
# Исполнитель “Раздвоитель” преобразует натуральные числа. У него есть две команды: “Вычесть 1” и “Разделить на 2”,
# первая команда уменьшает число на 1, вторая команда уменьшает число в два раза, если оно чётное,
# иначе происходит ошибка. Дано два натуральных числа A и B (A>B). Напишите алгоритм для Раздвоителя,
# который преобразует число A в число B и при этом содержит минимальное число команд.
# Команды алгоритма нужно выводить по одной в строке, первая команда обозначается, как -1, вторая команда как :2.
a, b = int(input()), int(input())
while a != b:
    if a // b >= 2 and a % 2 == 0:
        a //= 2
        print(':2')
    else:
        a -= 1
        print(-1)

# 43 Обращение числа
# Переставьте цифры числа в обратном порядке.
n = int(input())
k = 1
while n % k != n:
    print(n // k % 10, end='')
    k *= 10

# 44 Количество палиндромов
# Назовем число палиндромом, если оно не меняется при перестановке его цифр в обратном порядке.
# Напишите программу, которая по заданному числу K выводит количество натуральных палиндромов, не превосходящих K.
# Задано единственное число K (1≤K≤100000).
# Необходимо вывести количество натуральных палиндромов, не превосходящих K.
k = int(input())
count = 0
while k >= 1:
    x = 1
    rev = ''
    while k % x != k:
        rev += str(k // x % 10)
        x *= 10
    if k == int(rev):
        count += 1
    k -= 1
print(count)

# 45 Максимальное число подряд идущих равных
# Дана последовательность натуральных чисел, завершающаяся числом 0.
# Определите, какое наибольшее число подряд идущих элементов этой последовательности равны друг другу.
num = int(input())
count = 1
max_count = 1
prev_num = num
while num != 0:
    num = int(input())
    if num == prev_num:
        count += 1
    elif count > max_count:
        max_count = count
        count = 1
    else:
        count = 1
    prev_num = num
print(max_count)

# 46 Максимальная длина монотонного фрагмента
# Дана последовательность натуральных чисел, завершающаяся числом 0.
# Определите наибольшую длину монотонного фрагмента последовательности
# (то есть такого фрагмента, где все элементы либо больше предыдущего, либо меньше).
num = int(input())
count = 1
max_count = 1
prev_num = num
while num != 0:
    while num > prev_num:
        count += 1
        prev_num = num
        num = int(input())
    if count > max_count:
        max_count = count
    count = 1
    while num < prev_num and num != 0:
        count += 1
        prev_num = num
        num = int(input())
    if count > max_count:
        max_count = count
    count = 1
    if num == prev_num:
        prev_num = num
        num = int(input())
print(max_count)

# 47 Наименьшее расстояние между локальными максимумами
# Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел,
# завершающейся числом 0. Локальным максимумом называется такое число в последовательности,
# которое больше своих соседей. Если в последовательности нет двух локальных максимумов, выведите число 0.
# Начальное и конечное значение при этом локальными максимумами не считаются.
num_next = int(input())
count_num = 0
num, num_prev = num_next, num_next
l_max1, l_max2 = 0, 0
min_distance, distance = 0, 0
while num_next != 0:
    num_prev, num = num, num_next
    num_next = int(input())
    count_num += 1
    if num_prev < num > num_next and (num_next != 0):
        if l_max1 == 0:
            l_max1, l_max2 = count_num, count_num
        else:
            l_max1 = l_max2
            l_max2 = count_num
            distance = l_max2 - l_max1
        if min_distance == 0 or distance < min_distance:
            min_distance = distance
print(min_distance)
